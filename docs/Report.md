# <center>TypeORM –– ORM для TypeScript </center>
## 1. Почему нам понадобился тайпорм
В погоне за написанием масштабируемых веб приложений мы (`jnlp`) решили, что к месту будет использовать возможности TypeScript и самый популярный для веб приложений написаных на TypeScript ОРМ - TypeORM. 

### Основные заслуги TypeORM:
- достаточно низкий уровень вхождения, что отлично подходит для нас, студентов;

- наличие развитой инфраструктуры;

- автоматизация большого количества процессов, которые ранее писались вручную;

Прелесть использования объектно-реляционного отображения перед типичным написанием запросов к базе данных напрямую из кода состоит в том, что можно делать всё тоже, но используя объектно-ориентированую парадигму и автоматизировать большинство процессов, таких как генерация и миграция таблиц баз данных.

## 2. Что такое TypeORM
TypeORM это ОРМ, которая может запускаться в NodeJS, Browser, Cordova, и другие, и может использоваться с TypeScript и JavaScript. Его цель - всегда поддерживать новейшие функции JavaScript и предоставлять дополнительные функции, которые помогут вам разрабатывать любые приложения, использующие базы данных - от небольший приложений с несколькими таблицами до крупномасштабных корпоративных приложений с несколькими базами данных. 

TypeORM используется на всех этапах разработки слоя данных ПО. С помощью заранее прописаных типизированых энтити мы можем иметь в коде интерфейс, который будет дублировать модель отображения данных в бд и сразу предоставлять доступ к большому количеству операций над данными.

## 3. Начало работы
[Документация](https://typeorm.io/#/) и [развитое сообщество](https://join.slack.com/t/typeorm/shared_invite/enQtNDQ1MzA3MDA5MTExLTUxNTZhM2Q4NDNhMjMzNjQ2NGM1ZjI1ZGRkNjJjYzI4OTZjMGYyYTc0MzAxYTdjMWE3ZDIxOWUzZTdlM2QxNTY).

### 3.1 Установка
Установить npm пакет:
```bash
npm install typeorm --save
```

Возможно потребуется установить node typings:
```bash
npm install @types/node --save
```

Установить драйвер для PostreSQL:
```bash
npm install pg --save
```
Также поддерживаются MySQL, MariaDB, PostgreSQL, CockroachDB, SQLite, Microsoft SQL Server, sql.js, Oracle, SAP Hana, MongoDB.

### 3.2 Подключение к базе данных
Ваше взаимодействие с базой данных возможно только после настройки соединения. TypeORM Сonection не устанавливает соединение с базой данных, как может показаться, вместо этого оно устанавливает пул соединений. Если вы заинтересованы в реальном соединении с базой данных, обратитесь к документации QueryRunner. Каждый экземпляр QueryRunner представляет собой отдельное изолированное соединение с базой данных. Настройка пула подключений устанавливается после вызова метода подключения. Метод connect вызывается автоматически, если мы устанавливаете соединение с помощью функции createConnection. Разъединение (закрытие всех соединений в пуле) производится при вызове close. Как правило, мы должны создать соединение только один раз в загрузчике приложения и закрыть его после того, как полностью завершите работу с базой данных. На практике, если мы создаете бэкэнд для своего сайта и ваш бэкэнд-сервер всегда работает - мы никогда не закроем соединение.

```typescript
import { createConnection } from 'typeorm';

export const databaseProviders = [
  {
    provide: 'DATABASE_CONNECTION',
    useFactory: async () =>
      await createConnection({
        type: 'mysql',
        host: 'localhost',
        port: 3306,
        username: 'root',
        password: 'test',
        database: 'test',
        entities: [__dirname + '/../**/*.entity{.ts,.js}'],
        synchronize: true,
      }),
  },
];
```
В данном примере мы подключаемся к MySQL. Мы добавили наши список entities для этого подключения. Все entities, что используем, должны быть указаны здесь. Настройка синхронизации гарантирует, что ваши объекты будут синхронизироваться с базой данных при каждом запуске приложения.

Также можно использовать ConnectionManager для сохранения инстанса connection и передачу его через всю програму.

``` typescript
import {getConnectionManager, ConnectionManager, Connection} from "typeorm";

const connectionManager = getConnectionManager();
const connection = connectionManager.create({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "test",
    password: "test",
    database: "test",
});
await connection.connect(); // performs connection
```

### 3.3 Написание энтити
Работа с базы данных начинается с создания таблица. Энтити в модели декорированы `@Entity` декоратором. Для таких моделей будет создана таблица базы данных. Мы работаем с объектами везде с TypeORM. Мы можем загружать, вставлять, обновлять, удалять и выполнять другие операции с ними.

Чтобы добавить столбцы базы данных, вам просто нужно декорировать свойства энтити, которые мы хотим сделать, в столбец с помощью декоратора `@Column`.

Каждый объект должен иметь хотя бы один столбец первичного ключа - это обязательное требование. Чтобы сделать столбец первичным ключом, вам нужно использовать декоратор `@PrimaryColumn`.

Теперь предположим, что мы хотим, чтобы ваш столбец идентификаторов генерировался автоматически. Для этого вам нужно изменить декоратор `@PrimaryColumn` на декоратор `@PrimaryGeneratedColumn`:

Итак, созданим энтити пользователя:
```typescript
import { Entity, Column, PrimaryGeneratedColumn, OneToMany } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn('uuid')
  user_id?: string;

  @Column()
  email: string;

  @Column()
  username: string;

  @Column()
  password: string;
}
```

Сейчас будет создана бд таблица для энтити юзера и мы сможем работать с ней откуда угодно с нашего приложения.

Также существуют несколько специальных колонок для добавления дополнительного функционала:

- `@CreateDateColumn` -  дата вставки объекта. Вам не нужно устанавливать этот столбец - он будет установлен автоматически.

- `@UpdateDateColumn` -  время обновления сущности при каждом вызове сохранения менеджера или хранилища сущностей. Вам не нужно устанавливать этот столбец - он будет установлен автоматически.

- `@DeleteDateColumn` -  время удаления объекта каждый раз, когда мы вызываем soft-delete менеджера или репозитория объектов. Вам не нужно устанавливать этот столбец - он будет установлен автоматически. Если установлен @DeleteDateColumn, область по умолчанию будет «не удалена».

- `@VersionColumn` - версия объекта (инкрементный номер)
каждый раз, когда мы вызываем сохранение менеджера сущностей или хранилища. Вам не нужно устанавливать этот столбец - он будет установлен автоматически.

Мы также можем создать столбец з генерированым значением используя `@Generated` декоратор.

```typescript
@Entity()
export class User {

    @PrimaryColumn()
    id: number;

    @Column()
    @Generated("uuid")
    uuid: string;
}
```

Существует перечень необязательных настроек колонок, вот основные из их:

- `type: ColumnType` - Тип столбца. Один из перечисленных выше типов.

- `name: string` - имя столбца в таблице базы данных. По умолчанию имя столбца генерируется из имени свойства. Мы можем изменить его, указав свое имя.

- `length: number` - длина типа столбца. Например, если мы хотим создать тип varchar (150), мы указываете параметры типа и длины столбца.

- `primary: boolean` - Помечает столбец как основной. То же самое, если мы используем `@PrimaryColumn`.

- `unique: boolean` - Помечает столбец как уникальный столбец (создает уникальное ограничение).

- `comment: string` - комментарий к столбцу базы данных. Не поддерживается всеми типами баз данных.

- `enum: string [] | AnyEnum` - Используется в типе столбца enum для указания списка допустимых значений enum. Мы можем указать массив значений или указать класс перечисления.

- `transformer: {from (значение: DatabaseType): EntityType, to (значение: EntityType): DatabaseType}` - используется для преобразования свойств произвольного типа EntityType в тип DatabaseType, поддерживаемый базой данных. Массив преобразователей также поддерживается и будет применяться в естественном порядке при записи и в обратном порядке при чтении. например [нижний регистр, шифрование] сначала строчную строчку, затем шифрует ее при записи, и расшифровывает, а затем ничего не делает при чтении.

Энтити также могут наследоваться от других:
```typescript
export abstract class Content {

    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    title: string;

    @Column()
    description: string;

}
@Entity()
export class Post extends Content {

    @Column()
    viewcount: string;

}
```

### 3.4 Связи

Связи помогаю работать с связаными энтити. Вот несколько типов связей:

- один-к-одному использует `@OneToOne`
- многие-к-одному использует `@ManyToOne`
- один-к-многим использует `@OneToMany`
- многие-к-многим использует `@ManyToMany`

Опции, которые можно установить для связей:

- `eager: boolean` - если установлено значение true, отношение всегда будет загружаться с основным энтити при использовании методов find * или QueryBuilder для этого энтити

- `cascade: boolean | ("insert" | "update") []` - Если установлено значение true, связанный энтити будет вставлен и обновлен в базе данных. Вы также можете указать массив параметров каскада.

- `onDelete: "RESTRICT" | "CASCADE" | "SET NULL"` - указывает, как должен вести себя внешний ключ при удалении ссылочного объекта

- `primary: boolean` - Указывает, будет ли столбец этого отношения первичным или нет.

- `nullable: boolean` - указывает, является ли столбец этого отношения обнуляемым или нет. По умолчанию это обнуляется.

`@JoinColumn` не только определяет, какая сторона отношения содержит столбец соединения с внешним ключом, но также позволяет настраивать имя столбца соединения и имя столбца, на который ссылаются.

Когда мы устанавливаем `@JoinColumn`, он автоматически создает столбец в базе данных с именем `propertyName + referencedColumnName`. Например:

```typescript
@ManyToOne(type => Category)
@JoinColumn() // этот декоратор опционален для @ManyToOne, но обязателен для @OneToOne
category: Category;
```

`@JoinTable` используется для отношений «многие ко многим» и описывает столбцы соединения таблицы «junction». Соединительная таблица - это специальная отдельная таблица, автоматически создаваемая TypeORM со столбцами, которые ссылаются на связанные объекты. Мы можем изменить имена столбцов в таблицах соединений и их столбцах, на которые ссылаются, с помощью `@JoinColumn`: мы также можете изменить имя сгенерированной таблицы «соединений».

```typescript
@ManyToMany(type => Category)
@JoinTable({
    name: "question_categories", // имя таблицы для соединительной таблицы этого отношения
    joinColumn: {
        name: "question",
        referencedColumnName: "id"
    },
    inverseJoinColumn: {
        name: "category",
        referencedColumnName: "id"
    }
})
categories: Category[];
```

### 3.5 Репозиторий
Репозиторий это тот же EntityManager, но его операции ограничены запросами к конкретному энтити.

Мы можем получить доступ к репозиторию конкретного энтити просто передав в него необходимый тип

```typescript
import { Repository } from 'typeorm';

@Injectable()
export class UsersService {
  constructor(
    @Inject('USER_REPOSITORY')
    private userRepository: Repository<User>,
  ) {}
}
```

### 3.6 Запросы
Используя репозиторий, можно управлять (вставлять, обновлять, удалять, закружать, и т.д.). 

```typescript
import { Injectable, Inject, Logger } from '@nestjs/common';
import { User } from './user.entity';

@Injectable()
export class UsersService {
  async findByEmail(email: string): Promise<User> {
    Logger.debug('UsersService:findByEmail');
    return await this.userRepository.findOne({
      where: {
        email: email,
      },
    });
  }

  async create(user: User): Promise<User> {
    Logger.debug('UsersService:create');
    return await this.userRepository.save(user);
  }

  async remove(user_id: number): Promise<void> {
    Logger.debug('UsersService:remove');
    await this.userRepository.delete(user_id);
  }
}
```
Здесь мы использовали команды для загрузки (findOne), сохранения(save), и удаления(delete) с бд.

Ещё можно использовать для организации запросов к базе данных [QuerryBuilder](https://typeorm.io/#/select-query-builder)

## 4. Продвинутые техники

- [Миграции](https://typeorm.io/#/migrations)
- [Трансакции](https://typeorm.io/#/transactions)
- [Лисенеры и подписки](https://typeorm.io/#/listeners-and-subscribers)
- [Логирование](https://typeorm.io/#/logging)
- [Использование интерфейса командной строки](https://typeorm.io/#/using-cli)

## Спасибо за внимание. Доклад подготовлен [Стародубцем](https://github.com/MrILL) и [Лепейко](https://github.com/jn-lp).